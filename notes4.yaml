import CostEstimation from "../models/costestimination.model.js";
import axios from "axios";
import { PredictDisease } from "../models/newdrug.model.js";
import { ReactionResponse } from "../models/newdrug.model.js";
import { User } from "../models/auth.model.js";
import { MongoClient } from "mongodb";
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL =
  "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";

// Function to call Gemini AI for cost estimation
// Function to call Gemini AI for cost estimation
// Function to call Gemini AI for cost estimation
const geminiCostEstimation = async (smiles) => {
  try {
    const prompt = `
You are a pharmaceutical cost estimation AI that **must** follow this exact output format. Given the SMILES string "${smiles}", perform a step-by-step analysis and **always** return results in this structure:

---
**Estimated Cost:** \`$X–$Y per gram\`  
*(Precision: ±15% for lab-scale synthesis, ±30% for novel compounds)*  

**Introduction (1–2 sentences):**  
[Concise description of the molecule’s key features and common applications.]  

1. **Web Data & Structural Analysis**  
   - **IUPAC Name:** [Exact name from PubChem]  
   - **Key Structural Challenges:**  
     - [Number of stereocenters]  
     - [Problematic functional groups (e.g., esters, amines)]  
     - [Ring systems (e.g., fused heterocycles)]  
   - **Data Sources:** [PubChem, Sigma-Aldrich, MolPort, etc.]  

2. **Synthetic Feasibility & Route Details**  
   - **Primary Route:** [e.g., "Buchwald-Hartwig coupling → Esterification"]  
   - **Critical Steps:**  
     - Step 1: [Reaction type, yield %, cost/g]  
     - Step 2: [Reaction type, yield %, cost/g]  
   - **Total Theoretical Yield:** [X%]  

3. **Market Insights & Benchmarking**  
   - **Analog Pricing:** [e.g., "Similar API: $120/g (ChemSpace)"]  
   - **Bulk Discount Potential:** [e.g., "40% reduction at >1kg scale"]  
   - **Regulatory Costs:** [e.g., "None" or "Controlled precursor: +$20/g"]  

4. **Final Cost Drivers & Assumptions**  
   - **Major Cost Factors:**  
     - [e.g., "Chiral resolution (40% yield loss)"]  
     - [e.g., "Pd catalyst ($5/gram loading)"]  
   - **Warnings:**  
     - [e.g., "No patent data → assumes non-infringing route"]  
     - [e.g., "Air-sensitive steps raise handling costs"]  

---  

### **RULES YOU MUST FOLLOW:**  
1. **Never** return "N/A" – use "Not found (est. based on analogs)" if data is missing.  
2. **Prices must be in $X–$Y format** (e.g., "$150–$220").  
3. **Always fill all 4 sections**, even if brief.  
4. **Highlight uncertainties** in the "Warnings" subsection.  

### **EXAMPLE OUTPUT FOR "${smiles}":**  
**Estimated Cost:** \`$90–$140 per gram\`  

**Introduction:**  
A tertiary amine-containing scaffold with ester linkages, commonly seen in CNS drug candidates.  

1. **Web Data & Structural Analysis**  
   - **IUPAC Name:** Methyl 3-(diethylamino)-propanoate  
   - **Key Structural Challenges:**  
     - 1 stereocenter (racemic)  
     - Ester hydrolysis risk  
   - **Data Sources:** PubChem (CID: 12345), Sigma-Aldrich (Batch: 2024)  

2. **Synthetic Feasibility & Route Details**  
   - **Primary Route:** Reductive amination → Esterification  
   - **Critical Steps:**  
     - Step 1: Amine alkylation (72% yield, $12/g)  
     - Step 2: Esterification (55% yield, $8/g)  
   - **Total Theoretical Yield:** 40%  

3. **Market Insights & Benchmarking**  
   - **Analog Pricing:** Similar diester: $110/g (ZINC15)  
   - **Bulk Discount Potential:** 30% at >100g  
   - **Regulatory Costs:** None  

4. **Final Cost Drivers & Assumptions**  
   - **Major Cost Factors:**  
     - Low yielding final step  
     - THF solvent costs  
   - **Warnings:**  
     - No industrial route found → academic conditions assumed  
     - Palladium catalyst price volatility  
`;

    const response = await axios.post(
      GEMINI_API_URL,
      {
        contents: [{ role: "user", parts: [{ text: prompt }] }],
      },
      {
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": GEMINI_API_KEY,
        },
      }
    );

    let generatedText =
      response.data?.candidates?.[0]?.content?.parts?.[0]?.text ||
      "No response from AI";

    // Parse the response to extract the cost
    let estimatedCost = "N/A";
    let information = generatedText;

    // Look for a line like "Estimated Cost: $X–$Y per gram"
    const costRegex = /Estimated Cost: \$(\d+)(?:–\$(\d+))? per gram/i;
    const costMatch = generatedText.match(costRegex);

    if (costMatch) {
      const lowerBound = costMatch[1];
      const upperBound = costMatch[2] || lowerBound; // If no range, use the single value
      estimatedCost = `$${lowerBound}–$${upperBound} per gram`;
      // Remove the "Estimated Cost" line from the information
      information = generatedText.replace(costRegex, "").trim();
    } else {
      // Fallback: Look for any price range in the text (e.g., "$50–$100 per gram")
      const fallbackRegex = /\$(\d+)(?:–\$(\d+))? per gram/i;
      const fallbackMatch = generatedText.match(fallbackRegex);
      if (fallbackMatch) {
        const lowerBound = fallbackMatch[1];
        const upperBound = fallbackMatch[2] || lowerBound;
        estimatedCost = `$${lowerBound}–$${upperBound} per gram`;
      }
    }

    // Clean up the information: Remove stars and ensure proper formatting
    information = information
      .replace(/\*+/g, "") // Remove all stars
      .replace(/(\d+\.\s[A-Za-z\s]+:)/g, "\n$1") // Ensure numbered sections are on new lines
      .replace(/-+/g, "-") // Normalize dashes for bullet points
      .trim();

    return {
      estimatedcost: estimatedCost,
      information: information || "No additional information provided",
    };
  } catch (error) {
    console.error("Error calling Gemini AI:", error.message);
    return {
      estimatedcost: "Error estimating cost",
      information: "AI service unavailable",
    };
  }
};

// Post cost estimation using Gemini AI
export const postCostEstimation = async (req, res) => {
  try {
    const { smiles } = req.body;
    const userId = req.user?._id;

    if (!userId) {
      return res.status(401).json({ message: "User not authenticated" });
    }
    if (!smiles) {
      return res.status(400).json({ message: "SMILES string is required" });
    }

    const { estimatedcost, information } = await geminiCostEstimation(smiles);

    const costEstimation = new CostEstimation({
      smiles,
      estimatedcost,
      information,
      userId,
    });

    await costEstimation.save();

    res.status(201).json({
      success: true,
      data: costEstimation,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Server error",
      error: error.message,
    });
  }
};

// Get cost estimations for a user
export const getCostEstimation = async (req, res) => {
  try {
    const userId = req.user?._id;

    if (!userId) {
      return res.status(401).json({ message: "User not authenticated" });
    }

    const estimations = await CostEstimation.find({ userId }).sort({
      created: -1,
    });

    if (!estimations.length) {
      return res
        .status(404)
        .json({ message: "No cost estimations found for this user" });
    }

    res.status(200).json({
      success: true,
      data: estimations,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Server error",
      error: error.message,
    });
  }
};

// Adjust path to your PredictDisease model

// Combined endpoint to fetch symptoms by userId and all product_smiles

export const getSymptomsAndAllProducts = async (req, res) => {
  try {
    const userId = req.params.id;

    // Verify user exists
    const user = await User.findById(userId);
    if (!user) {
      console.error(`User not found for userId: ${userId}`);
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    // MongoDB connection for reaction_responses
    const client = new MongoClient(process.env.MONGODB_URI);
    await client.connect();
    const db = client.db("test");
    const reactionResponsesCollection = db.collection("reaction_responses");

    // Fetch symptoms and productSmileId from PredictDisease
    const predictDiseases = await PredictDisease.find({ userId }).select(
      "symptoms productSmileId"
    );
    console.log("PredictDisease documents:", predictDiseases);

    if (!predictDiseases || predictDiseases.length === 0) {
      console.warn(`No symptoms found for userId: ${userId}`);
      await client.close();
      return res
        .status(404)
        .json({ success: false, message: "No symptoms found for this user" });
    }

    // Define desired symptom groups
    const desiredSymptomGroups = [
      [
        "brittle toenails",
        "cracking knuckles",
        "ear blockage",
        "fluttering heartbeat",
        "sudden confusion",
      ],
      [
        "acidity",
        "blurred_and_distorted_vision",
        "depression",
        "excessive_hunger",
        "indigestion",
        "irritability",
        "stiff_neck",
        "visual_disturbances",
      ],
    ];

    // Filter and deduplicate symptoms
    const allSymptoms = [
      ...new Set(predictDiseases.flatMap((pd) => pd.symptoms)),
    ];
    const symptomGroups = desiredSymptomGroups
      .map((group) => group.filter((symptom) => allSymptoms.includes(symptom)))
      .filter((group) => group.length > 0);
    console.log("Filtered symptom groups:", symptomGroups);

    if (symptomGroups.length === 0) {
      console.warn(`No valid symptom groups for userId: ${userId}`);
      await client.close();
      return res
        .status(404)
        .json({ success: false, message: "No valid symptom groups found" });
    }

    // Collect productSmileIds
    const productSmileIds = predictDiseases
      .map((pd) => pd.productSmileId)
      .filter((id) => id)
      .map((id) => new ObjectId(id));
    console.log("Product Smile IDs:", productSmileIds);

    // Fetch product_smiles
    let productSmilesGroups = [];
    if (productSmileIds.length > 0) {
      const reactions = await reactionResponsesCollection
        .find(
          { _id: { $in: productSmileIds } },
          { projection: { product_smiles: 1 } }
        )
        .toArray();

      if (reactions.length > 0) {
        const allProductSmiles = reactions.map((r) =>
          r.product_smiles.filter((smiles) => smiles)
        );
        if (symptomGroups.length === 1) {
          productSmilesGroups = [[...new Set(allProductSmiles.flat())]];
        } else {
          const half = Math.ceil(allProductSmiles.length / 2);
          productSmilesGroups = [
            [...new Set(allProductSmiles.slice(0, half).flat())],
            [...new Set(allProductSmiles.slice(half).flat())],
          ];
        }
      }
    }

    // Fallback to all product_smiles if needed
    if (productSmilesGroups.length < symptomGroups.length) {
      const allProducts = await reactionResponsesCollection
        .find({}, { projection: { product_smiles: 1 } })
        .toArray();
      const allProductSmiles = [
        ...new Set(
          allProducts
            .flatMap((doc) => doc.product_smiles)
            .filter((smiles) => smiles)
        ),
      ];

      if (allProductSmiles.length > 0) {
        const groupSize = Math.ceil(
          allProductSmiles.length / symptomGroups.length
        );
        productSmilesGroups = symptomGroups.map((_, i) => {
          const start = i * groupSize;
          const end = start + groupSize;
          return allProductSmiles.slice(start, end);
        });
      } else {
        productSmilesGroups = symptomGroups.map(() => []);
      }
    }
    console.log("Product SMILES groups:", productSmilesGroups);

    // Close MongoDB connection
    await client.close();

    // Combine results
    const result = {
      success: true,
      userId,
      symptoms: symptomGroups, // Use arrays directly
      productSmiles: productSmilesGroups,
      message: productSmilesGroups.every((group) => group.length === 0)
        ? "No product SMILES found in reaction responses"
        : undefined,
    };

    console.log(`Successfully fetched data for userId: ${userId}`, result);
    return res.status(200).json(result);
  } catch (error) {
    console.error("Error in getSymptomsAndAllProducts:", error);
    return res.status(500).json({
      success: false,
      message: "Server error",
      error: error.message,
    });
  }
};
